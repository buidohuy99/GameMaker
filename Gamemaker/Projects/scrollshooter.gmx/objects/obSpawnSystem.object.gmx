<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Spawn System

enum SPAWN_SYSTEM_STATE                             //Basic state engine consisting of:
{                                                   //      Spawn       - creates enemies within the spawn zone.
    spawn,                                          //      Monitor     - checks if all enemies are destroyed.
    monitor,                                        //      Transition  - a short pause between waves. Also displays wave information.
    transition
}

//System 
state       = SPAWN_SYSTEM_STATE.transition;        //Start in the transition state to display the first wave information.
wave        = 0;                                    //Waves are incremented in the transition state, so set it to 0 here.
delay_spawn = 0.5;                                  //The time (in seconds) between each enemy being spawned.
delay_wave  = 6;                                    //The time (in seconds) between each wave.
timer       = delay_wave * room_speed;

//Spawn Zone Limits
origin_x    = x;                                    //This is the coordinate of the centre of the zone.
origin_y    = y;
radius_min  = 128;                                  //The minimum distance from the origin to spawn enemies.
radius_max  = 256;                                  //The maximum distance from the origin to spawn enemies.
                                                    //By setting both radii to the same value, enemies will spawn the same distance away.
angle_min   = 0;                                    //The spawn zone is clamped between these two angles. This allows you to specify a
angle_max   = 360;                                  //certain portion of the arc in which to spawn enemies.

//Enemy Variables
enemy_type[0] = obEnemy1;                           //You can add or take away from this 1D array in order to define each enemy type you
enemy_type[1] = obEnemy2;                           //want to have spawned. You should declare all enemies here, and then use the variables
enemy_type[2] = obEnemy3;                           //below to determine the number of each type to be spawned when increasing difficulty.

enemy_number    = 10;                               //This is how many enemies will be spawned in the current wave. (Initial value).
enemies_created = 0;                                //How many enemies have been created. (Don't change this).
allow_stacking  = false;                            //If true enemies will be allowed to spawn on top of each other.

enemy_type_min  = 0;                                //This is effectively the range of enemies. The spawn script will randomly select an enemy from
enemy_type_max  = 2;                                //the enemy_type array at a position within these two values. If you want to slowly introduce new enemies
                                                    //throughout the game then you can start off with small values and increase them every nth wave.
                                                    //If they are the same value then only that enemy type will be spawned.

//Display
display_wave    = delay_wave;                       //The time (in seconds) at which to start showing the next wave number when in the transition state.
display_count   = 3;                                //The time (in seconds) at which to start counting down to the next wave when in the transition state.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Process Spawn System

switch(state)
{
    case SPAWN_SYSTEM_STATE.spawn:
        if(timer &lt;= 0)
        {            
            var type, enemy, spawn_complete, dir, rad, spawn_x, spawn_y;
            
            type            = irandom_range(enemy_type_min, enemy_type_max);
            enemy           = instance_create(0, 0, enemy_type[type]);          //Create the enemy instance at an arbitrary location.
            spawn_complete  = false;                                            //The position will be calculated and tested if available later.
            
            repeat(20)                                                          //If the spawn position is occupied, the system will recalculate a new spawn position.
            {                                                                   //However, there is a chance that the game could hang if there are no available positions.
                dir     = random_range(angle_min, angle_max);                   //The repeat number can be increased or decreased, however if it doesn't manage to successfully spawn an enemy
                rad     = random_range(radius_min, radius_max);                 //the system will skip it and retry in the following frame thus preventing the game from hanging or causing a
                spawn_x = irandom_range(view_xview[0]+416,view_xview[0]+896)          //significant delay between enemy spawns (only one or two frames depending on the numebr of enemies) by not
                spawn_y = irandom_range(view_yview[0]+224,view_yview[0]+640)           //resetting the timer.
                
                if(allow_stacking)                                              //If enemies are allowed to spawn on top of each other then the spawn is complete.
                {
                    with(enemy)
                    {
                        x = spawn_x;
                        y = spawn_y;
                    }
                    spawn_complete = true;
                }
                else
                {
                    with(enemy)
                    {
                        x = spawn_x;
                        y = spawn_y;
                        
                        if(place_empty(x, y))                                   //If the enemy is in a free position, then remember that the spawn was succesfully completed in order to
                        {                                                       //break out of the repeat() loop.
                            spawn_complete = true;
                        }
                    }
                }
                if(spawn_complete)
                {
                    enemies_created++;
                    if(enemies_created &lt; enemy_number)
                    {
                        timer = delay_spawn * room_speed;
                    }
                    else
                    {
                        state = SPAWN_SYSTEM_STATE.monitor;
                    }
                    break;
                }
            }
            
            if(!spawn_complete)                                                 //Destroy the enemy to retry spawn in the next step.
            {
                with(enemy)
                {
                    instance_destroy();
                }
            }
        }
        else                                                                    //Simply count down the timer if it's greater than 0.
        {
            timer--;
        }
        break;
    
    
    case SPAWN_SYSTEM_STATE.monitor:
        var enemies_remaining = false;
        
        for(var i = 0; i &lt; array_length_1d(enemy_type); i++)
        {
            if(instance_exists(enemy_type[i]))                                  //Determine if there are any enemy instances of any of the declared types remaining.
            {
                enemies_remaining = true;
                break;                                                          //If there are, there is no point continuing through the the whole array so break out early.
            }
        }
        
        if(!enemies_remaining)                                                  //If no enemy instances exist then the player has destroyed them all.
        {
            timer = delay_wave * room_speed;
            state = SPAWN_SYSTEM_STATE.transition
        }
        break;
    
    
    case SPAWN_SYSTEM_STATE.transition:
        if(timer &lt;= 0)                                                          //Update the system variables.
        {
            wave++;
            enemies_created = 0;
            
            if(wave &gt; 1)
            {
                //delay_spawn       = 0.5;                                      //Increase difficulty. These are all the variables you can adjust to increase the difficulty.
                //enemy_type_min    = 0;
                enemy_number       += 3;
                enemy_type_max      = min(enemy_type_max + 1,                     //This will add a new enemy type every wave until it reaches the limit of enemy types.
                                          array_length_1d(enemy_type) - 1);
            }
            state = SPAWN_SYSTEM_STATE.spawn;                                   //Recommence spawning.
        }
        else
        {
            timer--;
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw Wave Information

if(state == SPAWN_SYSTEM_STATE.transition)
{
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    
    if(timer &lt;= display_wave * room_speed)
    {
        draw_set_font(fnSpawnSystem_Wave);
        draw_text(display_get_gui_width() * 0.5, display_get_gui_height() * 0.5 - 16, "Wave " + string(wave + 1));
    }
    
    if(timer &lt;= display_count * room_speed)
    {
        draw_set_font(fnSpawnSystem_Count);
        draw_text(display_get_gui_width() * 0.5, display_get_gui_height() * 0.5 + 16, "Starting in " + string(ceil(timer / room_speed)));
    }
    
    draw_set_halign(fa_left);   //Reset draw variables
    draw_set_valign(fa_top);
    draw_set_font(-1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Debug Draw Spawn Zone

//You can use this for testing, or delete it. It is not required for the system to work.

draw_circle(origin_x, origin_y, radius_min, true);

draw_circle(origin_x, origin_y, radius_max, true);

draw_line(origin_x + lengthdir_x(radius_min, angle_min), origin_y + lengthdir_y(radius_min, angle_min),
            origin_x + lengthdir_x(radius_max, angle_min), origin_y + lengthdir_y(radius_max, angle_min));

draw_line(origin_x + lengthdir_x(radius_min, angle_max), origin_y + lengthdir_y(radius_min, angle_max),
            origin_x + lengthdir_x(radius_max, angle_max), origin_y + lengthdir_y(radius_max, angle_max));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
